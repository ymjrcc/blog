<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mobx 学习笔记]]></title>
    <url>%2Fblog%2F2017%2F12%2F07%2Flearn-mobx%2F</url>
    <content type="text"><![CDATA[mobx 引入了几个概念，Observable state, Derivations 和 Reactions。 可以拿 Excel 表格做个比喻，Observable state 是单元格，Derivations 是计算公式，单元格的修改会触发公司的重新计算，并返回值，而最终公式的计算结果需要显示在屏幕上(比如通过图表的方式)，这是 Reactions。 通过 @observable 定义 Observable state，通过 @computed 定义 Derivations，通过 @observer 封装了 React Component 的 render 方法，这是 Reactions。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import &#123; observable, computed, autorun &#125; from 'mobx';import &#123; observer &#125; from 'mobx-react';import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';////////////////////// Storeclass TodoStore &#123; @observable todos = []; constructor() &#123; autorun(() =&gt; console.log(this.report)); &#125; @computed get report() &#123; return `todos' length = $&#123;this.todos.length&#125;`; &#125; @computed get completedTodosCount() &#123; return this.todos.filter(todo =&gt; todo.completed === true).length; &#125; addTodo(task) &#123; this.todos.push(&#123; task, completed: false &#125;); &#125;&#125;////////////////////// Components@observerclass TodoList extends Component &#123; render() &#123; const &#123; todoStore &#125; = this.props; return ( &lt;div&gt; &#123; todoStore.todos.map((todo, index) =&gt; &lt;Todo todo=&#123;todo&#125; key=&#123;index&#125; /&gt;) &#125; Progress: &#123; todoStore.completedTodosCount &#125; &lt;/div&gt; ); &#125;&#125;@observerclass Todo extends Component &#123; render() &#123; const &#123; todo &#125; = this.props; return ( &lt;li onDoubleClick=&#123;this.onRename&#125;&gt; &lt;input type="checkbox" checked=&#123; todo.completed &#125; onChange=&#123; this.onToggleCompleted &#125; /&gt; &#123; todo.task &#125; &lt;/li&gt; ); &#125; onToggleCompleted = () =&gt; &#123; const todo = this.props.todo; todo.completed = !todo.completed; &#125; onRename = () =&gt; &#123; const todo = this.props.todo; todo.task = prompt('Task name', todo.task) || ""; &#125;&#125;////////////////////// Initconst todoStore = new TodoStore();todoStore.addTodo('foo');todoStore.addTodo('bar');ReactDOM.render( &lt;TodoList todoStore=&#123;todoStore&#125; /&gt;, document.getElementById('mount')); @observale 修饰器让对象可以被追踪； @computed 修饰器创造了自动运算的表达式； autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错； @observer 修饰器让 React 组件自动更新 国际惯例撸个 TodoList = = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import React, &#123; Component &#125; from 'react';import &#123; observable, computed, autorun &#125; from 'mobx';import &#123; observer &#125; from 'mobx-react';import styles from './TodoListMobx.module.css';class TodoStore &#123; constructor() &#123; autorun(() =&gt; console.log(this.report)); &#125; @observable inputVal = ''; @observable todos = [ &#123;name: '打扫房间', completed: false&#125;, &#123;name: '阅读', completed: false&#125;, &#123;name: '学习 mobx', completed: true&#125;, ]; @observable status = 'all'; @computed get report() &#123; return `todos' length = $&#123;this.todos.length&#125;`; &#125; addTodo(task)&#123; this.todos.push(&#123;name: task, completed: false&#125;); this.inputVal = ''; &#125;&#125;@observerclass Filter extends Component &#123; render()&#123; const &#123;status, handleFilter&#125; = this.props; return &lt;div className=&#123;styles.filter&#125;&gt; &lt;span&gt;&#123;status==='all'?'全部':&lt;a id='all' href='javascript:;' onClick=&#123;handleFilter&#125;&gt;全部&lt;/a&gt;&#125;&lt;/span&gt; &lt;span&gt;&#123;status==='completed'?'已完成':&lt;a id='completed' href='javascript:;' onClick=&#123;handleFilter&#125;&gt;已完成&lt;/a&gt;&#125;&lt;/span&gt; &lt;span&gt;&#123;status==='notcompleted'?'未完成':&lt;a id='notcompleted' href='javascript:;' onClick=&#123;handleFilter&#125;&gt;未完成&lt;/a&gt;&#125;&lt;/span&gt; &lt;/div&gt; &#125;&#125;@observerclass TodoListMobx extends Component &#123; handleInput = (e) =&gt; &#123; this.props.todoStore.inputVal = e.target.value; &#125; handleAdd = () =&gt; &#123; const &#123;todoStore&#125; = this.props; if(todoStore.inputVal.trim().length===0)&#123; alert('todo 事项不能为空！'); &#125;else&#123; todoStore.addTodo(todoStore.inputVal); &#125; &#125; handleCompleted = (e) =&gt; &#123; const &#123;todoStore&#125; = this.props; const newTodos = todoStore.todos; newTodos[e.target.id].completed = e.target.checked; todoStore.todos = newTodos; &#125; handleFilter = (e) =&gt; &#123; this.props.todoStore.status = e.target.id; &#125; render() &#123; const &#123; todoStore &#125; = this.props; const todos = todoStore.todos .filter(item =&gt; &#123; const &#123;status&#125; = todoStore; if(status==='all')&#123; return true; &#125;else if(status==='completed')&#123; return item.completed===true; &#125;else if(status==='notcompleted')&#123; return item.completed===false; &#125; &#125;) .map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt; &lt;label&gt;&lt;input type='checkbox' id=&#123;index&#125; checked=&#123;item.completed&#125; onChange=&#123;this.handleCompleted&#125; /&gt; &#123;item.completed?&lt;del&gt;&#123;item.name&#125;&lt;/del&gt;:item.name&#125;&lt;/label&gt; &lt;/li&gt;); return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;todoStore.inputVal&#125; onChange=&#123;this.handleInput&#125; placeholder='需要添加的事项名' /&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123;todos&#125; &lt;/ul&gt; &lt;Filter status = &#123;todoStore.status&#125; handleFilter=&#123;this.handleFilter&#125; /&gt; &lt;/div&gt; ); &#125;&#125;const todoStore = new TodoStore();export default () =&gt; &lt;TodoListMobx todoStore=&#123;todoStore&#125; /&gt;; 参考资料： MobX 官方文档 MobX 入门教程 by sorycc 使用mobx开发高性能react应用 我为什么从Redux迁移到了Mobx by 有赞 MobX 入门教程 Mobx使用详解 MobX —— 10分钟极速入门 MobX 与 React]]></content>
      <tags>
        <tag>react</tag>
        <tag>mobx</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code 常用操作]]></title>
    <url>%2Fblog%2F2017%2F12%2F01%2Fvscode%2F</url>
    <content type="text"><![CDATA[快捷键 cmd + shift + V 打开预览视图（写 md 的时候很方便） cmd + \ 当前文件分屏（文件太长需要跳来跳去看的时候） shift + alt + ↑/↓ 复制当前行到上一行/下一行 shift + alt + 鼠标左键 批量选中文本并编辑 修改文件缩进及格式化在窗口底栏右侧可选择使用空格还是 tab、每次缩进多少个空格。选择后可以 shift + alt + F 格式化代码。 编写 snippets按 F1 键，选择“首选项：打开用户代码段”选择语言，根据提示编写。 支持 decorator用户设置中，&quot;javascript.implicitProjectConfig.experimentalDecorators&quot;: true(上面只是使得 vs code 不报错，要真正使用还需要安装相应 babel 插件，见 create-react-app 一文) 在非 html 文件里快捷打出 html 元素 install HTML Snippets extension Go to the extensions folder matching your OS ( Mac: ~/.vscode/extensions ) Find the extension abusaidm.html-snippets-x.x.x Find package.json inside the extension’s directory and open it with any text editor, e.g. VSC Locate the sections with snippets and you will see: 123456789&#123; "language": "html", "path": "./snippets/snippets.json"&#125;//Add the below snippet with another language you want.,&#123; "language": "NEW LANGUAGE", "path": "./snippets/snippets.json"&#125; Close VSCode and start it again, I have noticed a reload doesn’t always work as intended, now the extension should work with the languages you added.Example of languages: php、javascript、javascriptreact 参考链接]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 Decorator 小结]]></title>
    <url>%2Fblog%2F2017%2F11%2F30%2FDecorator%2F</url>
    <content type="text"><![CDATA[这几天因为要学习 mobx，把 ES7 Decorator 的语法翻出来复习了一下，在这里做个归纳总结。 123456@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。 修饰器可以给类添加静态属性，也可以添加实例属性。如果想添加实例属性，可以通过目标类的 prototype 对象操作。 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true 修饰器不仅可以修饰类，还可以修饰类的属性。 1234class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 此时，修饰器函数一共可以接受三个参数： 第一个参数是所要修饰的目标对象，即类的实例（这不同于类的修饰，那种情况时 target 参数指的是类本身）； 第二个参数是所要修饰的属性名； 第三个参数是该属性的描述对象。 123456789101112131415function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); core-decorators.js是一个第三方模块，提供了几个常见的修饰器。如 @autobind、@readonly、@override 等。 在 create-react-app 中使用 decorators： https://www.npmjs.com/package/custom-react-scripts]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2Fhello%20world%2F</url>
    <content type="text"><![CDATA[距离上次开博客已经两年多了，两年前在 github-pages 上用 jekyll 搭了一个简易的博客，然而懒癌晚期写了三篇就无疾而终。时隔两年，我变秃了，也变强了！在学习和工作的过程中，觉得有一个载体来记录和总结自己的思考和成长过程还是必须的。之前一直用 OneNote 做笔记，但换了 Mac 后发现很多功能都不支持了，心想还是博客方便，故决心重开一个。 昨天简单调研了一下几个受欢迎的博客框架，然后就被 hexo 所深深吸引了，安装配置简单灵活，还有各种好看的主题……就决定是你了！主题用的是 hexo 社区最受欢迎的 NexT。 粗略浏览了一遍文档后就开撸。搭好环境测试了一下没问题，我把原先的GitHub 上的博客仓库改了个名字扔到一边，替换成了现在这个。新增了两个仓库： Yiming_Blog：这是博客脚手架仓库，包括本地环境、主题、各种配置以及 md 格式的博文等。 blog：这是上面那个项目自动生成部署的静态博客站点源码，在 Yiming_Blog 中配置好后，用 markdown 写完博客，在项目根目录直接执行 hexo g -d 命令，就能生成相应的静态页面，一键发布到我的 github-pages 上，通过 这个链接 即可访问。 博客的大部分配置通过修改项目中的 _config.yml 文件来实现。与博客框架相关的配置文件在根目录下，与主题相关的配置文件在 theme 文件夹对应的主题文件夹里。具体参考 hexo 官方文档 、NexT 官方文档 。 在生成 GitHub 仓库时遇到一个问题。由于 NexT 主题我是 git clone 到 theme 文件夹里的，所以它本身就是一个 git 仓库，而 Yiming_Blog 也是一个 git 仓库，于是就形成了大仓库嵌套小仓库的现象。这会导致小仓库里的改动无法被大仓库捕获。于是我把小仓库的 .git 文件夹删除了，使其恢复为普通文件夹，与大仓库融为一体。虽然这样做对将来主题版本更新不是很方便，但考虑到主题版本也不会经常更新，就先这样吧。以后如果要更新主题版本，记得先把 _config.yml 备份一下就好。 好了，暂时先交代这么多吧。希望这次可以坚持久一点，做到笔耕不辍，在持续总结中不断提高自己的姿势水平！ hexo 常用操作： hexo new &lt;title&gt; //写新文章 hexo new draft &lt;title&gt; //建立草稿 hexo publish &lt;title&gt; //发布草稿 hexo s //本地运行 hexo s --draft //本地预览草稿 hexo clean //清除缓存 hexo g -d //生成静态文件并部署到服务器 hexo 中引入图片等资源： 将资源文件放在 source 文件夹下对应的文件夹里 在文章中用 md 语法引入： 在根目录下：![](/images/img1.jpg) 在子目录/path下：![](/path/images/img2.jpg)(若博客放在网站子目录下，如www.mywebsite.com/blog，记得图片路径前也要加上子目录，否则无法解析！)]]></content>
      <tags>
        <tag>杂</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
